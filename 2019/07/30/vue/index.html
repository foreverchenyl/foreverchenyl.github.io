<!DOCTYPE html>




<html class="theme-next pisces" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
    
  
  <link href="https://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet" type="text/css">




  
  
  
  

  

  

  

  

  

  
    

    
  

  
    
    
    <link href="//fonts.cat.net/css?family=Sigmar One:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






  

<link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.css" rel="stylesheet" type="text/css">



  

<link href="https://cdn.bootcss.com/social-share.js/1.0.9/css/share.min.css" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=0.0.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=0.0.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=0.0.4">


  <link rel="mask-icon" href="/images/logo.svg?v=0.0.4" color="#222">





  <meta name="keywords" content="vue,">










<meta name="description" content="Start Vue ~">
<meta name="keywords" content="vue">
<meta property="og:type" content="article">
<meta property="og:title" content="Vue Learning">
<meta property="og:url" content="http://foreverchenyl.github.io/2019/07/30/vue/index.html">
<meta property="og:site_name" content="Hi,YuLong">
<meta property="og:description" content="Start Vue ~">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://images2015.cnblogs.com/blog/938664/201705/938664-20170522225458132-1434604303.png">
<meta property="og:image" content="https://vuex.vuejs.org/vuex.png">
<meta property="og:updated_time" content="2019-08-02T09:54:37.492Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Vue Learning">
<meta name="twitter:description" content="Start Vue ~">
<meta name="twitter:image" content="https://images2015.cnblogs.com/blog/938664/201705/938664-20170522225458132-1434604303.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '0.0.4',
    sidebar: {"position":"right","display":"always","offset":52,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    since: '7/2/2019 11:30:00',
    onlineAPI: '',
    site: {
      title: 'Hi,YuLong',
      subtitle: '',
      author: 'YuLong'
    },
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    leancloud: {
      enable: false,
      appID: '',
      appKey: ''
    },
    favicon: {
      visibilitychange: true,
      narmal: '/images/favicon.ico',
      hidden: '/images/failure.ico',
      show_text: '(/≧▽≦/)咦！又好了！',
      hide_text: '(●—●)喔哟，崩溃啦！'
    }
  };
</script>



  
    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/2.1.3/jquery.min.js"></script>




  <link rel="canonical" href="http://foreverchenyl.github.io/2019/07/30/vue/">





  <title>Vue Learning | Hi,YuLong</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-48084758-7', 'auto');
  ga('send', 'pageview');
</script>





</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-rocket"></i> <br>
            
            关于
          </a>
        </li>
      

      
      <li class="menu-item search">
          <form class="search-form">
            <input name="keyword" type="text" class="search-input" placeholder="站内搜索">
            <button type="submit" class="search-submit"><i class="fa fa-search"></i></button>
          </form>
      </li>
     <!-- <li class="menu-item online"><span id="online-count">?</span>人在线</li> -->
    </ul>
  

  
</nav>

<div class="site-brand-wrapper" style="background-image: url(/images/header-sagiri.jpg)">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <div class="brand">
        <span class="logo-line-before"><i></i></span>
        <div class="site-title">
          <div id="animate" class="animate">
            <span>H</span><span>i</span><span>,</span><span>Y</span><span>u</span><span>L</span><span>o</span><span>n</span><span>g</span>
          </div>
          <div id="guide" class="guide">
            <span>H</span><span>i</span><span>,</span><span>Y</span><span>u</span><span>L</span><span>o</span><span>n</span><span>g</span>
          </div>
        </div>
        <span class="logo-line-after"><i></i></span>
      </div>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>
<div class="site-master" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-master-avatar" itemprop="image" src="/images/DIYgod.jpg" alt="YuLong">
    <h2 class="site-master-description" itemprop="description">
        
    </h2>
</div>


 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-date">
			<div class="post-month">07月</div>
			<div class="post-day">30</div>
	</div>
  
  <div class="post-badge">
    
      <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
        <a href="/categories/前端/" itemprop="url" rel="index">
          <span itemprop="name">前端</span>
        </a>
      </span>
    
  </div>
  

  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://foreverchenyl.github.io/2019/07/30/vue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="YuLong">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/DIYgod.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hi,YuLong">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Vue Learning</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-30T16:29:00+08:00">
                2019-07-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">•</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>Start Vue <del>~</del></p>
<a id="more"></a>

<h2 id="1、组件间通信方式"><a href="#1、组件间通信方式" class="headerlink" title="1、组件间通信方式"></a>1、组件间通信方式</h2><p>Vue的官方文档对组件间的通信方式做了详细的说明：<a href="https://link.juejin.im?target=https%3A%2F%2Fcn.vuejs.org" target="_blank" rel="noopener">cn.vuejs.org</a></p>
<h3 id="父组件向子组件传输"><a href="#父组件向子组件传输" class="headerlink" title="父组件向子组件传输"></a>父组件向子组件传输</h3><ul>
<li>最常用的方式是在子组件标签上传入数据，在子组件内部用<code>props</code>接收：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;children name=&quot;boy&quot;&gt;&lt;/children&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">// 子组件：children</span><br><span class="line">export default &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    name: String</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ul>
<li>还可以在子组件中用 <code>this.$parent</code> 访问父组件的实例，不过官方文档有这样一段文字，很好的说明了 <code>$parent</code> 的意义：节制地使用 <code>$parent</code> 和 <code>$children</code> —— 它们的主要目的是作为访问组件的应急方法。更推荐用 <code>props</code> 和 <code>events</code> 实现父子组件通信。</li>
<li></li>
</ul>
<h3 id="子组件向父组件传输"><a href="#子组件向父组件传输" class="headerlink" title="子组件向父组件传输"></a>子组件向父组件传输</h3><p>vue中子组件调用父组件的方法：</p>
<p>参考： <a href="https://www.cnblogs.com/jin-zhe/p/9523782.html" target="_blank" rel="noopener">https://www.cnblogs.com/jin-zhe/p/9523782.html</a></p>
<p>第一种方法是直接在子组件中通过this.$parent.event来调用父组件的方法</p>
<p>第二种方法是在子组件里用<code>$emit</code>向父组件触发一个事件，父组件监听这个事件就行了。</p>
<p>第三种是父组件把方法传入子组件中，在子组件里直接调用这个方法</p>
<ul>
<li>一般在子组件中使用 <code>this.$emit(&#39;eventName&#39;, &#39;data&#39;)</code>，然后在父组件中的子组件标签上监听 <code>eventName</code> 事件，并在参数中获取传过来的值。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 子组件</span><br><span class="line">export default &#123;</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    this.$emit(&apos;mounted&apos;, &apos;Children is mounted.&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;children @mounted=&quot;mountedHandle&quot;&gt;&lt;/children&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">// 父组件</span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    mountedHandle (data) &#123;</span><br><span class="line">      console.log(data) // Children is mounted.</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>与 <code>$parent</code> 一样，在父组件中可以通过访问 <code>this.$children</code> 来访问组件的所有子组件实例。</li>
</ul>
<h3 id="非父子组件之间的数据传递"><a href="#非父子组件之间的数据传递" class="headerlink" title="非父子组件之间的数据传递"></a>非父子组件之间的数据传递</h3><ul>
<li><p>对于非父子组件间，且具有复杂组件层级关系的情况，可以通过 <code>Vuex</code> 进行组件间数据传递： <a href="https://link.juejin.im?target=https%3A%2F%2Fvuex.vuejs.org%2Fzh%2F" target="_blank" rel="noopener">vuex.vuejs.org/zh/</a></p>
</li>
<li><p>在 <code>Vue 1.0</code> 中常用的 <code>event bus</code> 方式进行的全局数据传递，在 <code>Vue 2.0</code> 中已经被移除，官方文档中有说明：<code>$dispatch</code> 和 <code>$broadcast</code> 已经被弃用。请使用更多简明清晰的组件间通信和更好的状态管理方案，如：<code>Vuex</code>。</p>
</li>
</ul>
<h2 id="2、双向绑定原理"><a href="#2、双向绑定原理" class="headerlink" title="2、双向绑定原理"></a>2、双向绑定原理</h2><p>vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty()来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p>
<p><a href="https://link.juejin.im?target=https%3A%2F%2Fblog.seosiwei.com%2Fdetail%2F35" target="_blank" rel="noopener">blog.seosiwei.com/detail/35</a> <a href="https://link.juejin.im?target=https%3A%2F%2Fblog.seosiwei.com%2Fdetail%2F36" target="_blank" rel="noopener">blog.seosiwei.com/detail/36</a> <a href="https://link.juejin.im?target=https%3A%2F%2Fblog.seosiwei.com%2Fdetail%2F37" target="_blank" rel="noopener">blog.seosiwei.com/detail/37</a></p>
<ul>
<li>在组件内部实现一个双向数据绑定</li>
</ul>
<p>假设有一个输入框组件，用户输入时，同步父组件页面中的数据<br>具体思路：父组件通过 props 传值给子组件，子组件通过 $emit 来通知父组件修改相应的props值，具体实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line"></span><br><span class="line">const component = &#123;</span><br><span class="line">  props: [&apos;value&apos;],</span><br><span class="line">  template: `</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input type=&quot;text&quot; @input=&quot;handleInput&quot; :value=&quot;value&quot;&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  `,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleInput (e) &#123;</span><br><span class="line">      this.$emit(&apos;input&apos;, e.target.value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    CompOne: component</span><br><span class="line">  &#125;,</span><br><span class="line">  el: &apos;#root&apos;,</span><br><span class="line">  template: `</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;comp-one :value1=&quot;value&quot; @input=&quot;value = arguments[0]&quot;&gt;&lt;/comp-one&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  `,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      value: &apos;123&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>我们在父组件中做了两件事，一是给子组件传入props，二是监听input事件并同步自己的value属性。那么这两步操作能否再精简一下呢？答案是可以的，你只需要修改父组件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template: `</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;!--&lt;comp-one :value1=&quot;value&quot; @input=&quot;value = arguments[0]&quot;&gt;&lt;/comp-one&gt;--&gt;</span><br><span class="line">      &lt;comp-one v-model=&quot;value&quot;&gt;&lt;/comp-one&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  `</span><br></pre></td></tr></table></figure>

<p>v-model 实际上会帮我们完成上面的两步操作。</p>
<p>vue数据双向绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的，vue是通过Object.defineProperty()来实现数据劫持的。通过Object.defineProperty( )设置了对象Book的name属性，对其get和set进行重写操作，顾名思义，get就是在读取name属性这个值触发的函数，set就是在设置name属性这个值触发的函数。</p>
<p><strong>实现过程</strong>:</p>
<p>我们已经知道实现数据的双向绑定，首先要对数据进行劫持监听，所以我们需要设置一个监听器Observer，用来监听所有属性。如果属性发上变化了，就需要告诉订阅者Watcher看是否需要更新。因为订阅者是有很多个，所以我们需要有一个消息订阅器Dep来专门收集这些订阅者，然后在监听器Observer和订阅者Watcher之间进行统一管理的。接着，我们还需要有一个指令解析器Compile，对每个节点元素进行扫描和解析，将相关指令对应初始化成一个订阅者Watcher，并替换模板数据或者绑定相应的函数，此时当订阅者Watcher接收到相应属性的变化，就会执行对应的更新函数，从而更新视图。因此接下去我们执行以下3个步骤，实现数据的双向绑定：</p>
<p>1.实现一个监听器Observer，用来劫持并监听所有属性，如果有变动的，就通知订阅者。</p>
<p>2.实现一个订阅者Watcher，可以收到属性的变化通知并执行相应的函数，从而更新视图。</p>
<p>3.实现一个解析器Compile，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅器。</p>
<p>流程图如下：</p>
<p><img src="https://images2015.cnblogs.com/blog/938664/201705/938664-20170522225458132-1434604303.png" alt="img"></p>
<h2 id="3、路由导航钩子"><a href="#3、路由导航钩子" class="headerlink" title="3、路由导航钩子"></a>3、路由导航钩子</h2><p><a href="https://link.juejin.im?target=https%3A%2F%2Frouter.vuejs.org%2Fzh-cn%2Fadvanced%2Fnavigation-guards.html" target="_blank" rel="noopener">router.vuejs.org/zh-cn/advan…</a></p>
<h2 id="4、对MVVM开发模式的理解"><a href="#4、对MVVM开发模式的理解" class="headerlink" title="4、对MVVM开发模式的理解"></a>4、对MVVM开发模式的理解</h2><p>MVVM分为Model、View、ViewModel三者。<br><strong>Model</strong> 代表数据模型，数据和业务逻辑都在Model层中定义；<br><strong>View</strong> 代表UI视图，负责数据的展示；<br><strong>ViewModel</strong> 负责监听 <strong>Model</strong> 中数据的改变并且控制视图的更新，处理用户交互操作；<br><strong>Model</strong> 和 <strong>View</strong> 并无直接关联，而是通过 <strong>ViewModel</strong> 来进行联系的，<strong>Model</strong> 和 <strong>ViewModel</strong> 之间有着双向数据绑定的联系。因此当 <strong>Model</strong> 中的数据改变时会触发 <strong>View</strong> 层的刷新，<strong>View</strong> 中由于用户交互操作而改变的数据也会在 <strong>Model</strong> 中同步。<br>这种模式实现了 <strong>Model</strong> 和 <strong>View</strong> 的数据自动同步，因此开发者只需要专注对数据的维护操作即可，而不需要自己操作 <strong>dom</strong>。</p>
<h2 id="5、vue的响应式原理"><a href="#5、vue的响应式原理" class="headerlink" title="5、vue的响应式原理"></a>5、vue的响应式原理</h2><p>当一个Vue实例创建时，vue会遍历data选项的属性，用 <strong>Object.defineProperty</strong> 将它们转为 getter/setter并且在内部追踪相关依赖，在属性被访问和修改时通知变化。<br>每个组件实例都有相应的 watcher 程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新。</p>
<h2 id="6、vue指令及属性"><a href="#6、vue指令及属性" class="headerlink" title="6、vue指令及属性"></a>6、vue指令及属性</h2><p><strong>(1) 常见指令:</strong></p>
<ul>
<li><p>v-text、v-on</p>
</li>
<li><p>v-if(判断是否隐藏)、v-for(把数据遍历出来)、v-bind(绑定属性)、v-model(实现双向绑定)</p>
</li>
<li><p>v-model.trim、v-model.number、v-model.lazy</p>
</li>
<li><p>v-html、v-show、v-if、v-for等等</p>
</li>
<li><p>v-if 和 v-show 的区别: </p>
<p>v-show 仅仅控制元素的显示方式，将 display 属性在 block 和 none 来回切换；而v-if会控制这个 DOM 节点的存在与否。当我们需要经常切换某个元素的显示/隐藏时，使用v-show会更加节省性能上的开销；当只需要一次显示或隐藏时，使用v-if更加合理.</p>
<ul>
<li><p>相同点： 两者都是在判断DOM节点是否要显示</p>
</li>
<li><p>不同点：</p>
<p> a.实现方式： v-if是根据后面数据的真假值判断直接从Dom树上删除或重建元素节点。  v-show只是在修改元素的css样式，也就是display的属性值，元素始终在Dom树上。</p>
<p>  b.编译过程：v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；  v-show只是简单的基于css切换；</p>
<p>  c.编译条件：v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译； v-show是在任何条件下（首次条件是否为真）都被编译，然后被缓存，而且DOM元素始终被保留；</p>
<p>  d.性能消耗：v-if有更高的切换消耗，不适合做频繁的切换；  v-show有更高的初始渲染消耗，适合做频繁的额切换</p>
<p><code>v-show</code> 不支持 <code>&lt;template&gt;</code> 元素，也不支持 <code>v-else</code></p>
<ul>
<li><p>v-for 与 v-if 的优先级</p>
<p>v-for的优先级比v-if高</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>(2) 计算属性、  侦听属性、侦听器(watch)</strong></p>
<ul>
<li><a href="https://cn.vuejs.org/v2/guide/computed.html#计算属性的-setter" target="_blank" rel="noopener">计算属性的 setter</a></li>
</ul>
<p>计算属性默认只有 getter ，不过在需要时你也可以提供一个 setter ：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  fullName: &#123;</span><br><span class="line">    <span class="comment">// getter</span></span><br><span class="line">    <span class="keyword">get</span>: function () &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">' '</span> + <span class="keyword">this</span>.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// setter</span></span><br><span class="line">    <span class="keyword">set</span>: function (newValue) &#123;</span><br><span class="line">      <span class="keyword">var</span> names = newValue.split(<span class="string">' '</span>)</span><br><span class="line">      <span class="keyword">this</span>.firstName = names[<span class="number">0</span>]</span><br><span class="line">      <span class="keyword">this</span>.lastName = names[names.length - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。这就是为什么 Vue 通过 <code>watch</code> 选项提供了一个更通用的方法，来响应数据的变化。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。</p>
<h2 id="7、vue-组件中-data"><a href="#7、vue-组件中-data" class="headerlink" title="7、vue 组件中 data"></a>7、vue 组件中 data</h2><p>在 <code>new Vue()</code> 中，<code>data</code> 是可以作为一个对象进行操作的，然而在 <code>component</code> 中，<code>data</code> 只能以函数的形式存在，不能直接将对象赋值给它。</p>
<p>当data选项是一个函数的时候，<strong>每个实例可以维护一份被返回对象的独立的拷贝</strong>，这样各个实例中的data不会相互影响，是独立的</p>
<h2 id="8、vue生命周期钩子函数"><a href="#8、vue生命周期钩子函数" class="headerlink" title="8、vue生命周期钩子函数"></a>8、vue生命周期钩子函数</h2><p>参考： <a href="https://www.jianshu.com/p/8b7373362b4c" target="_blank" rel="noopener">https://www.jianshu.com/p/8b7373362b4c</a></p>
<p>总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后。</p>
<p>　　创建前/后</p>
<p>　　在beforeCreated阶段，vue实例的挂载元素$el和数据对象data都为undefined，还未初始化。</p>
<p>　　在created阶段，vue实例的数据对象data有了，$el还没有。</p>
<p>　　载入前/后</p>
<p>　　在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。</p>
<p>　　在mounted阶段，vue实例挂载完成，data.message成功渲染。</p>
<p>　　更新前/后</p>
<p>　　当data变化时，会触发beforeUpdate和updated方法。</p>
<p>　　销毁前/后</p>
<p>　　在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在</p>
<h2 id="9、computed-和-watched-的区别"><a href="#9、computed-和-watched-的区别" class="headerlink" title="9、computed 和 watched 的区别"></a>9、computed 和 watched 的区别</h2><p>computed 是计算属性，依赖其他属性计算值，并且 computed 的值有缓存，只有当计算值变化才会返回内容。<strong>计算属性是基于它们的响应式依赖进行缓存的</strong>，只在相关响应式依赖发生改变时它们才会重新求值。</p>
<p>watch 监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。</p>
<p>所以一般来说需要依赖别的属性来动态获得值的时候可以使用 computed，对于监听到值的变化需要做一些复杂业务逻辑的情况可以使用 watch。</p>
<h2 id="10、vuex"><a href="#10、vuex" class="headerlink" title="10、vuex"></a>10、vuex</h2><p>Vuex 是一个专为 Vue.js 应用程序开发的<strong>状态管理模式</strong>。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p>
<p>每一个 Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的<strong>状态 (state)</strong>。</p>
<p><img src="https://vuex.vuejs.org/vuex.png" alt="vuex"></p>
<p>Vuex 通过 <code>store</code> 选项，提供了一种机制将状态从根组件“注入”到每一个子组件中（需调用 <code>Vue.use(Vuex)</code>）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  <span class="comment">// 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件</span></span><br><span class="line">  store,</span><br><span class="line">  components: &#123; Counter &#125;,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div class="app"&gt;</span></span><br><span class="line"><span class="string">      &lt;counter&gt;&lt;/counter&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>通过在根实例中注册 <code>store</code> 选项，该 store 实例会注入到根组件下的所有子组件中，且子组件能通过 <code>this.$store</code> 访问到。让我们更新下 <code>Counter</code> 的实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Counter = &#123;</span><br><span class="line">  template: <span class="string">`&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`</span>,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    count () &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.count</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1、vuex的属性？</p>
<p>答：有五种，分别是 State、 Getter、Mutation 、Action、 Module</p>
<p>1.1、state</p>
<p>​        state为单一状态树，在state中需要定义我们所需要管理的数组、对象、字符串等等，只有在这里定义了，在vue.js的组件中才能获取你定义的这个对象的状态。</p>
<ul>
<li><p>mapState</p>
</li>
<li><p>State特性</p>
</li>
</ul>
<p>Vuex就是一个仓库，仓库里面放了很多对象。其中state就是数据源存放地，对应于与一般Vue对象里面的data。<br>state里面存放的数据是响应式的，Vue组件从store中读取数据，若是store中的数据发生改变，依赖这个数据的组件也会发生更新。<br>它通过mapState把全局的 state 和 getters 映射到当前组件的 computed 计算属性中。</p>
<p>1.2、getter</p>
<p>​        getter有点类似vue.js的计算属性，当我们需要从store的state中派生出一些状态，那么我们就需要使用getter，getter会接收state作为第一个参数，而且getter的返回值会根据它的依赖被缓存起来，只有getter中的依赖值（state中的某个需要派生状态的值）发生改变的时候才会被重新计算。</p>
<p>虽然在组件内也可以做计算属性，但是getters 可以在多组件之间复用</p>
<ul>
<li><p>也可以通过让 getter 返回一个函数，来实现给 getter 传参。在你对 store 里的数组进行查询时非常有用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getters: &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  getTodoById: <span class="function">(<span class="params">state</span>) =&gt;</span> <span class="function">(<span class="params">id</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> state.todos.find(<span class="function"><span class="params">todo</span> =&gt;</span> todo.id === id)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>mapGetters</p>
</li>
</ul>
<p>1.3、mutation</p>
<p>​        更改store中state状态的唯一方法就是提交mutation，就很类似事件。每个mutation都有一个字符串类型的事件类型和一个回调函数，我们需要改变state的值就要在回调函数中改变。我们要执行这个回调函数，那么我们需要执行一个相应的调用方法：store.commit。</p>
<p>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。</p>
<p>mutation 都是同步事务。</p>
<p><a href="https://vuex.vuejs.org/zh/guide/mutations.html" target="_blank" rel="noopener">mutation</a></p>
<p>1.4、action</p>
<p>​        action可以提交mutation，在action中可以执行store.commit，而且action中可以有任何的异步操作。在页面中如果我们要嗲用这个action，则需要执行store.dispatch</p>
<p>Action 类似于 mutation，不同在于：</p>
<ul>
<li>Action 提交的是 mutation，而不是直接变更状态。</li>
<li>Action 可以包含任意异步操作。</li>
</ul>
<p>调用异步 API 和分发多重 mutation</p>
<p>1.5、module</p>
<p>​        module其实只是解决了当state中很复杂臃肿的时候，module可以将store分割成模块，每个模块中拥有自己的state、mutation、action和getter。</p>

      
    </div>
    
    
    

    

    
      <div class="post-share">分享到：</div>
    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/vue/" rel="tag"># vue</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/07/25/net/" rel="next" title="C#, .NET">
                <i class="fa fa-chevron-left"></i> C#, .NET
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/08/02/frontend/" rel="prev" title="Web Front End">
                Web Front End <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  





  




	





  





  













        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/card.jpg" alt="YuLong">
            
              <p class="site-author-name" itemprop="name"><span style="opacity:.2;">Codeing </span>YuLong</p>
              <p class="site-description motion-element" itemprop="description">Keep up with me!</p>
          </div>

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/foreverchenyl" target="_blank" title="GitHub" data-balloon="GitHub" data-balloon-pos="up">
                    
                      <i class="fa fa-fw fa-github"></i></a>
                </span>
              
            
          </div>

          

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            
            

          </nav>

          
          
            <div class="cc-license motion-element" itemprop="license">
              <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" target="_blank">
                <img src="/images/cc-by-nc-sa.png" alt="Creative Commons">
              </a>
            </div>
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1、组件间通信方式"><span class="nav-number">1.</span> <span class="nav-text">1、组件间通信方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#父组件向子组件传输"><span class="nav-number">1.1.</span> <span class="nav-text">父组件向子组件传输</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#子组件向父组件传输"><span class="nav-number">1.2.</span> <span class="nav-text">子组件向父组件传输</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#非父子组件之间的数据传递"><span class="nav-number">1.3.</span> <span class="nav-text">非父子组件之间的数据传递</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2、双向绑定原理"><span class="nav-number">2.</span> <span class="nav-text">2、双向绑定原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3、路由导航钩子"><span class="nav-number">3.</span> <span class="nav-text">3、路由导航钩子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4、对MVVM开发模式的理解"><span class="nav-number">4.</span> <span class="nav-text">4、对MVVM开发模式的理解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5、vue的响应式原理"><span class="nav-number">5.</span> <span class="nav-text">5、vue的响应式原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6、vue指令及属性"><span class="nav-number">6.</span> <span class="nav-text">6、vue指令及属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7、vue-组件中-data"><span class="nav-number">7.</span> <span class="nav-text">7、vue 组件中 data</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8、vue生命周期钩子函数"><span class="nav-number">8.</span> <span class="nav-text">8、vue生命周期钩子函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9、computed-和-watched-的区别"><span class="nav-number">9.</span> <span class="nav-text">9、computed 和 watched 的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10、vuex"><span class="nav-number">10.</span> <span class="nav-text">10、vuex</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-image"></div>
      <div class="footer-inner">
        <p>博客已萌萌哒运行<span id="since"></span><span class="my-face">(●'◡'●)ﾉ♥</span></p>
<p>前端萌新，哈哈哈 ~</p>

<p>© <span itemprop="copyrightYear">2019</span> Hi,YuLong.
    由 <a href="https://hexo.io/" target="_blank" class="external" rel="nofollow">Hexo</a> 强力驱动.
    Theme By <a href="https://github.com/DIYgod/hexo-theme-sagiri" target="_blank" class="external" rel="nofollow">Sagiri</a> v0.0.4.
    <a href="/sitemap.xml" target="_blank">站点地图</a>.
    xxxx.
</p>
<p>Made with <i class="fa fa-heart throb" style="color: #d43f57;"></i> by <span class="author" itemprop="copyrightHolder">YuLong</span>. </p>

        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    <canvas id="evanyou"></canvas>

    

  </div>

  <script type="text/javascript" src="/js/sagiri.min.js?v=0.0.4"></script>

  





  

  
  

  

  

  

</body>
</html>
